// NOTE: The following comment line is mandatory for T4 to work correctly. Don't remove it
// <#+
#if !KUSTO_BUILD || DEBUG
#if KUSTO_BUILD
namespace Kusto.Language.Generator
{
    using System;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading.Tasks;
#endif

    /// <summary>
    /// A utility class for writing the text of other programs.
    /// </summary>
    /// <remarks>This class does not take a dependency on anything not in the BCL.</remarks>
    public class CodeGenerator
    {
        #region Private data
        private StringWriter m_swriter;
        private IndentedTextWriter m_writer;
        private bool m_emptyAbove;
        #endregion

        #region Construction
        public CodeGenerator()
        {
            m_swriter = new StringWriter();
            m_writer = new IndentedTextWriter(m_swriter, "    ");
            m_emptyAbove = true;
        }
        #endregion

        #region Public API
        /// <summary>
        /// Gets the full program text written thus far.
        /// </summary>
        public string GetText()
        {
            return m_swriter.ToString();
        }

        public void WriteHeader(string templateExtension, string templateName)
        {
            WriteLine(@"
// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------
// <autogenerated>
//   This file was generated automatically from a {0} file that included
//   the {1} file.
//   Do not modify this file by hand -- modify the original {0} file.
//   Do not check-in this file!
// </autogenerated>

// Disable pragma warnings for auto-generated code
#pragma warning disable 472,429 
", templateExtension, templateName);
        }

        /// <summary>
        /// Add a block of "using namespace X".
        /// </summary>
        /// <param name="usingNamespaces">The custom namespaces to "use" in the block.</param>
        /// <param name="addBclNamespaces">Whether to add a few useful BCL namespace.</param>
        /// <param name="addKcpNamespaces">Whether to add a few useful Kusto.Cloud.Platform namespaces.</param>
        public void WriteUsingBlock(IEnumerable<string> usingNamespaces, bool addBclNamespaces, bool addKcpNamespaces)
        {
            var bclCommonNamespaces = new[]
            {
                "System",
                "System.Collections.Generic",
                "System.Globalization",
                "System.Runtime.Serialization",
            };

            var kcpNamespaces = new List<string>
            {
                "Kusto.Cloud.Platform.Utils"
            };

            var nsCommon = new List<string>();
            var nsDotNetOnly = new List<string>();

            if (addBclNamespaces)
            {
                foreach (var namspace in bclCommonNamespaces)
                {
                    if (!nsCommon.Contains(namspace))
                    {
                        nsCommon.Add(namspace);
                    }
                }
              
            }
            if (addKcpNamespaces)
            {
                foreach (var namspace in kcpNamespaces)
                {
                    if (!nsCommon.Contains(namspace))
                    {
                        nsCommon.Add(namspace);
                    }
                }
            }
            if (usingNamespaces != null)
            {
                foreach (var namspace in usingNamespaces)
                {
                    if (!nsCommon.Contains(namspace))
                    {
                        nsCommon.Add(namspace);
                    }
                }
            }

            foreach (string n in nsCommon)
            {
                WriteLine("using {0};", n);
            }
        }

        /// <summary>
        /// Writes a namespace declaration and inside it runs a continuation action.
        /// The namespace declaration is closed automatically once the action returns.
        /// </summary>
        /// <param name="namespace">The namespace to create.</param>
        /// <param name="inside">The action to run inside the namespace.</param>
        public void WriteNamespaceDeclaration(string @namespace, Action inside)
        {
            WriteNamespaceDeclarationBegin(@namespace);
            inside();
            WriteNamespaceDeclarationEnd();
        }

        /// <summary>
        /// Writes the beginning part of a namespace declaration.
        /// </summary>
        public void WriteNamespaceDeclarationBegin(string @namespace)
        {
            WriteLine();
            WriteLine("namespace {0}", @namespace);
            WriteLine("{");
            m_writer.Indent++;
        }

        /// <summary>
        /// Writes the ending part of a namespace declaration.
        /// </summary>
        public void WriteNamespaceDeclarationEnd()
        {
            m_writer.Indent--;
            WriteLine("}");
        }

        /// <summary>
        /// Writes an "if(@if) { inside(); }" block
        /// </summary>
        public void WriteIfBlock(string @if, Action inside)
        {
            WriteScopeStart($"if ({@if})");
            inside();
            WriteScopeEnd();
        }

        /// <summary>
        /// Writes an "if(@if) { body }" block
        /// </summary>
        public void WriteIfBlock(string @if, string body)
        {
            WriteScopeStart($"if ({@if})");
            WriteLine(body);
            WriteScopeEnd();
        }

        public void WriteRegion(string region, Action inside)
        {
            WriteRegionBegin(region);
            inside();
            WriteRegionEnd(region);
        }

        public void WriteRegionBegin(string region)
        {
            WriteEmptyLineIfNeeded();
            WriteLine("#region {0}", region);
            m_emptyAbove = true;
        }

        public void WriteRegionEnd(string region)
        {
            WriteLine("#endregion /* {0} */", region);
        }

        public void WriteDocString(string summary, string remarks = null)
        {
            if (!string.IsNullOrWhiteSpace(summary))
            {
                WriteLine("/// <summary>");
                WriteLine("/// {0}", summary);
                WriteLine("/// </summary>");
            }

            if (!string.IsNullOrEmpty(remarks))
            {
                WriteLine("/// <remarks>");
                WriteLine("/// {0}", remarks);
                WriteLine("/// </remarks>");
            }
        }

        /// <summary>
        /// Writes a string and a new indented scope, calls the action,
        /// then ends the scope.
        /// </summary>
        /// <param name="head">The string preceding the new scope.</param>
        /// <param name="inside">The action to run inside the scope.</param>
        public void WriteScope(string head, Action inside)
        {
            WriteScopeStart(head);
            inside();
            WriteScopeEnd();
        }

        public void WriteScopeStart()
        {
            WriteLine("{");
            m_writer.Indent++;
        }

        public void WriteScopeStart(string head)
        {
            WriteLine(head);
            WriteLine("{");
            m_writer.Indent++;
        }

        public void WriteScopeEnd()
        {
            m_writer.Indent--;
            WriteLine("}");
        }

        public void UnsafeIndent()
        {
            m_writer.Indent++;
        }

        public void UnsafeUnindent()
        {
            m_writer.Indent--;
        }

        /// <summary>
        /// If the line above the current line is not empty, write a new line.
        /// </summary>
        public void WriteEmptyLineIfNeeded()
        {
            if (!m_emptyAbove)
            {
                WriteLine(null);
            }
        }

        public void WriteLine()
        {
            WriteLine(null);
        }

        private static readonly string[] c_newline = new string[] { System.Environment.NewLine };

        public void WriteLine(string text, bool detectNewLines = true)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                m_emptyAbove = true;
                m_writer.WriteLine();
                return;
            }

            if (detectNewLines && text.Contains(Environment.NewLine))
            {
                var lines = text.Split(c_newline, StringSplitOptions.None);
                foreach (var line in lines)
                {
                    m_writer.WriteLine(line);
                }
            }
            else
            {
                m_writer.WriteLine(text);
            }
            if (text.EndsWith(Environment.NewLine) || text.EndsWith("{"))
            {
                m_emptyAbove = true;
            }
            else
            {
                m_emptyAbove = false;
            }
        }

        public void WriteLine(string format, params object[] args)
        {
            var text = string.Format(format, args);
            WriteLine(text);
        }
        #endregion

        #region Static utility methods
        /// <summary>
        /// Given a compoundName/CompoundName, returns the corresponding PascalCase 
        /// version of the name (CompoundName).
        /// </summary>
        public static string GetPascalCase(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
            var first = Char.ToUpper(name[0]);
            if (name.Length == 1)
            {
                return first.ToString();
            }
            return first + name.Substring(1);
        }

        /// <summary>
        /// Given a compoundName/CompoundName, returns the corresponding CamelCase
        /// version of the name (compoundName).
        /// </summary>
        public static string GetCamelCase(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
            {
                return name;
            }
            var first = Char.ToLower(name[0]);
            if (name.Length == 1)
            {
                return first.ToString();
            }
            var ret = first + name.Substring(1);
            if (ret == "operator") // Add here all C# keywords people dream up
            {
                return "@" + ret;
            }
            return ret;
        }

        /// <summary>
        /// Given a compoundName/CompoundName, returns the corresponding ClassMemberName
        /// version of the name(m_compoundName).
        /// </summary>
        public static string GetClassMemberName(string name)
        {
            return "m_" + GetCamelCase(name);
        }
        #endregion
    }
#if KUSTO_BUILD
}
#endif 
#endif
// NOTE: The following comment line is mandatory for T4 to work correctly. Don't remove it
// #>
